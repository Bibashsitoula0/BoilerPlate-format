//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class NavigationService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7184";
    }

    getNavigationByRoleId(roleID: string | undefined): Observable<ResponseOfListOfNavigationByRoleId> {
        let url_ = this.baseUrl + "/api/Navigation/GetNavigationByRoleId?";
        if (roleID === null)
            throw new Error("The parameter 'roleID' cannot be null.");
        else if (roleID !== undefined)
            url_ += "roleID=" + encodeURIComponent("" + roleID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNavigationByRoleId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNavigationByRoleId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseOfListOfNavigationByRoleId>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseOfListOfNavigationByRoleId>;
        }));
    }

    protected processGetNavigationByRoleId(response: HttpResponseBase): Observable<ResponseOfListOfNavigationByRoleId> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseOfListOfNavigationByRoleId;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    submitNavigationRole(navigation: NavigationByRoleId[]): Observable<ResponseOfNavigationByRoleId> {
        let url_ = this.baseUrl + "/api/Navigation/SubmitNavigationRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(navigation);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitNavigationRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitNavigationRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseOfNavigationByRoleId>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseOfNavigationByRoleId>;
        }));
    }

    protected processSubmitNavigationRole(response: HttpResponseBase): Observable<ResponseOfNavigationByRoleId> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseOfNavigationByRoleId;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getNavigationByRole(roleId: string | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Navigation/GetNavigationByRole?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNavigationByRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNavigationByRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetNavigationByRole(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CommonService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7184";
    }

    getAllFiscal(): Observable<ResponseOfListOfSelectList> {
        let url_ = this.baseUrl + "/api/Common/GetAllFiscal";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFiscal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFiscal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseOfListOfSelectList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseOfListOfSelectList>;
        }));
    }

    protected processGetAllFiscal(response: HttpResponseBase): Observable<ResponseOfListOfSelectList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseOfListOfSelectList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProvince(): Observable<ResponseOfListOfSelectList> {
        let url_ = this.baseUrl + "/api/Common/GetProvince";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProvince(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProvince(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseOfListOfSelectList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseOfListOfSelectList>;
        }));
    }

    protected processGetProvince(response: HttpResponseBase): Observable<ResponseOfListOfSelectList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseOfListOfSelectList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDistrictByProvinceIds(provinceIds: string | null | undefined): Observable<ResponseOfListOfSelectList> {
        let url_ = this.baseUrl + "/api/Common/GetDistrictByProvinceIds?";
        if (provinceIds !== undefined && provinceIds !== null)
            url_ += "provinceIds=" + encodeURIComponent("" + provinceIds) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDistrictByProvinceIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDistrictByProvinceIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseOfListOfSelectList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseOfListOfSelectList>;
        }));
    }

    protected processGetDistrictByProvinceIds(response: HttpResponseBase): Observable<ResponseOfListOfSelectList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseOfListOfSelectList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMultiplePalikaByMultipleDistrictIds(districtIds: string | null | undefined): Observable<ResponseOfListOfSelectList> {
        let url_ = this.baseUrl + "/api/Common/GetMultiplePalikaByMultipleDistrictIds?";
        if (districtIds !== undefined && districtIds !== null)
            url_ += "districtIds=" + encodeURIComponent("" + districtIds) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMultiplePalikaByMultipleDistrictIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMultiplePalikaByMultipleDistrictIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseOfListOfSelectList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseOfListOfSelectList>;
        }));
    }

    protected processGetMultiplePalikaByMultipleDistrictIds(response: HttpResponseBase): Observable<ResponseOfListOfSelectList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseOfListOfSelectList;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProvinceDistrictPalika(): Observable<ResponseOfListOfProvinceDistrictPalika> {
        let url_ = this.baseUrl + "/api/Common/GetProvinceDistrictPalika";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProvinceDistrictPalika(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProvinceDistrictPalika(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseOfListOfProvinceDistrictPalika>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseOfListOfProvinceDistrictPalika>;
        }));
    }

    protected processGetProvinceDistrictPalika(response: HttpResponseBase): Observable<ResponseOfListOfProvinceDistrictPalika> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseOfListOfProvinceDistrictPalika;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    accessAreaForProvince(model: ApproveProvinceDistrictPalika[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Common/AccessAreaForProvince";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccessAreaForProvince(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccessAreaForProvince(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processAccessAreaForProvince(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserDetails(token: string | undefined): Observable<ResponseOfUserWithNavigation> {
        let url_ = this.baseUrl + "/api/Common/GetUserDetails?";
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseOfUserWithNavigation>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseOfUserWithNavigation>;
        }));
    }

    protected processGetUserDetails(response: HttpResponseBase): Observable<ResponseOfUserWithNavigation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseOfUserWithNavigation;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    lockoutForFiscalYear(model: GiveAcessForFiscalYear): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Common/LockoutForFiscalYear";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLockoutForFiscalYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLockoutForFiscalYear(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processLockoutForFiscalYear(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllFiscalForChecked(): Observable<ResponseOfListOfFiscalYearsDto> {
        let url_ = this.baseUrl + "/api/Common/GetAllFiscalForChecked";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFiscalForChecked(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFiscalForChecked(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseOfListOfFiscalYearsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseOfListOfFiscalYearsDto>;
        }));
    }

    protected processGetAllFiscalForChecked(response: HttpResponseBase): Observable<ResponseOfListOfFiscalYearsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseOfListOfFiscalYearsDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllFiscalChildForChecked(fyid: number | undefined): Observable<ResponseOfListOfFiscalDetailDto> {
        let url_ = this.baseUrl + "/api/Common/GetAllFiscalChildForChecked?";
        if (fyid === null)
            throw new Error("The parameter 'fyid' cannot be null.");
        else if (fyid !== undefined)
            url_ += "fyid=" + encodeURIComponent("" + fyid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFiscalChildForChecked(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFiscalChildForChecked(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseOfListOfFiscalDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseOfListOfFiscalDetailDto>;
        }));
    }

    protected processGetAllFiscalChildForChecked(response: HttpResponseBase): Observable<ResponseOfListOfFiscalDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseOfListOfFiscalDetailDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AccountService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7184";
    }

    registerGeneralUser(id: string | undefined, userName: string | undefined, fullName: string | undefined, isactive: boolean | undefined, email: string | undefined, password: string | null | undefined, confirmpassword: string | null | undefined, role: string | null | undefined): Observable<ResponseOfApplicationUser> {
        let url_ = this.baseUrl + "/api/Account/RegisterGeneralUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (fullName === null)
            throw new Error("The parameter 'fullName' cannot be null.");
        else if (fullName !== undefined)
            url_ += "fullName=" + encodeURIComponent("" + fullName) + "&";
        if (isactive === null)
            throw new Error("The parameter 'isactive' cannot be null.");
        else if (isactive !== undefined)
            url_ += "isactive=" + encodeURIComponent("" + isactive) + "&";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (password !== undefined && password !== null)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        if (confirmpassword !== undefined && confirmpassword !== null)
            url_ += "confirmpassword=" + encodeURIComponent("" + confirmpassword) + "&";
        if (role !== undefined && role !== null)
            url_ += "role=" + encodeURIComponent("" + role) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterGeneralUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterGeneralUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseOfApplicationUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseOfApplicationUser>;
        }));
    }

    protected processRegisterGeneralUser(response: HttpResponseBase): Observable<ResponseOfApplicationUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseOfApplicationUser;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    login(userName: string | undefined, password: string | undefined): Observable<ResponseOfLoginReturnTypeDto> {
        let url_ = this.baseUrl + "/api/Account/Login?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (password === null)
            throw new Error("The parameter 'password' cannot be null.");
        else if (password !== undefined)
            url_ += "Password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseOfLoginReturnTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseOfLoginReturnTypeDto>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<ResponseOfLoginReturnTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseOfLoginReturnTypeDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    changePassword(oldPassword: string | undefined, newPassword: string | undefined, confirmNewPassword: string | undefined): Observable<ResponseOfUserPassword> {
        let url_ = this.baseUrl + "/api/Account/ChangePassword?";
        if (oldPassword === null)
            throw new Error("The parameter 'oldPassword' cannot be null.");
        else if (oldPassword !== undefined)
            url_ += "OldPassword=" + encodeURIComponent("" + oldPassword) + "&";
        if (newPassword === null)
            throw new Error("The parameter 'newPassword' cannot be null.");
        else if (newPassword !== undefined)
            url_ += "NewPassword=" + encodeURIComponent("" + newPassword) + "&";
        if (confirmNewPassword === null)
            throw new Error("The parameter 'confirmNewPassword' cannot be null.");
        else if (confirmNewPassword !== undefined)
            url_ += "ConfirmNewPassword=" + encodeURIComponent("" + confirmNewPassword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseOfUserPassword>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseOfUserPassword>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<ResponseOfUserPassword> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseOfUserPassword;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    changeUserPassword(userName: string | undefined, oldPassword: string | undefined, newPassword: string | undefined, confirmNewPassword: string | undefined): Observable<ResponseOfChangePassword> {
        let url_ = this.baseUrl + "/api/Account/ChangeUserPassword?";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (oldPassword === null)
            throw new Error("The parameter 'oldPassword' cannot be null.");
        else if (oldPassword !== undefined)
            url_ += "OldPassword=" + encodeURIComponent("" + oldPassword) + "&";
        if (newPassword === null)
            throw new Error("The parameter 'newPassword' cannot be null.");
        else if (newPassword !== undefined)
            url_ += "NewPassword=" + encodeURIComponent("" + newPassword) + "&";
        if (confirmNewPassword === null)
            throw new Error("The parameter 'confirmNewPassword' cannot be null.");
        else if (confirmNewPassword !== undefined)
            url_ += "ConfirmNewPassword=" + encodeURIComponent("" + confirmNewPassword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUserPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUserPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseOfChangePassword>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseOfChangePassword>;
        }));
    }

    protected processChangeUserPassword(response: HttpResponseBase): Observable<ResponseOfChangePassword> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseOfChangePassword;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    userList(pageNumber: number | null | undefined, pageSize: number | null | undefined, searchString: string | null | undefined): Observable<ResponseOfListOfUserListDto> {
        let url_ = this.baseUrl + "/api/Account/UserList?";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchString !== undefined && searchString !== null)
            url_ += "SearchString=" + encodeURIComponent("" + searchString) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseOfListOfUserListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseOfListOfUserListDto>;
        }));
    }

    protected processUserList(response: HttpResponseBase): Observable<ResponseOfListOfUserListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseOfListOfUserListDto;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRole(): Observable<ResponseOfListOfSelectListModel> {
        let url_ = this.baseUrl + "/api/Account/GetRole";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseOfListOfSelectListModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseOfListOfSelectListModel>;
        }));
    }

    protected processGetRole(response: HttpResponseBase): Observable<ResponseOfListOfSelectListModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseOfListOfSelectListModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateGeneralUser(id: string | undefined, userName: string | undefined, fullName: string | undefined, isactive: boolean | undefined, email: string | undefined, password: string | null | undefined, confirmpassword: string | null | undefined, role: string | null | undefined): Observable<ResponseOfApplicationUser> {
        let url_ = this.baseUrl + "/api/Account/UpdateGeneralUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (fullName === null)
            throw new Error("The parameter 'fullName' cannot be null.");
        else if (fullName !== undefined)
            url_ += "fullName=" + encodeURIComponent("" + fullName) + "&";
        if (isactive === null)
            throw new Error("The parameter 'isactive' cannot be null.");
        else if (isactive !== undefined)
            url_ += "isactive=" + encodeURIComponent("" + isactive) + "&";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (password !== undefined && password !== null)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        if (confirmpassword !== undefined && confirmpassword !== null)
            url_ += "confirmpassword=" + encodeURIComponent("" + confirmpassword) + "&";
        if (role !== undefined && role !== null)
            url_ += "role=" + encodeURIComponent("" + role) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGeneralUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGeneralUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseOfApplicationUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseOfApplicationUser>;
        }));
    }

    protected processUpdateGeneralUser(response: HttpResponseBase): Observable<ResponseOfApplicationUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseOfApplicationUser;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string | undefined): Observable<ResponseOfListOfApplicationUser> {
        let url_ = this.baseUrl + "/api/Account/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseOfListOfApplicationUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseOfListOfApplicationUser>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResponseOfListOfApplicationUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseOfListOfApplicationUser;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllRoles(): Observable<ResponseOfListOfSelectListModel> {
        let url_ = this.baseUrl + "/api/Account/GetAllRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseOfListOfSelectListModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseOfListOfSelectListModel>;
        }));
    }

    protected processGetAllRoles(response: HttpResponseBase): Observable<ResponseOfListOfSelectListModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseOfListOfSelectListModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ResponseOfListOfNavigationByRoleId {
    message?: string;
    status?: string;
    data?: NavigationByRoleId[];
}

export interface NavigationByRoleId {
    role_id?: string;
    parent_navigation?: string | undefined;
    navigation_id?: number;
    allowed?: boolean;
    navigation?: string;
    link?: string | undefined;
    navigation_type?: string | undefined;
    parent_navigation_id?: number | undefined;
    root_navigation_id?: number;
    icon?: string;
    display_order?: number;
    can_approve?: boolean;
    showin_ui?: boolean;
    can_create?: boolean;
    can_edit?: boolean;
    can_review?: boolean;
    can_delete?: boolean;
    can_full_access?: boolean;
}

export interface ResponseOfNavigationByRoleId {
    message?: string;
    status?: string;
    data?: NavigationByRoleId;
}

export interface ResponseOfListOfSelectList {
    message?: string;
    status?: string;
    data?: SelectList[];
}

export interface SelectList {
    key?: number;
    value?: string;
    points?: number;
    isChecked?: boolean;
}

export interface ResponseOfListOfProvinceDistrictPalika {
    message?: string;
    status?: string;
    data?: ProvinceDistrictPalika[];
}

export interface ProvinceDistrictPalika {
    provinceid?: number;
    provincename?: string;
    provincenamenepali?: string;
    province_active?: boolean;
    district?: DistrictVm;
}

export interface DistrictVm {
    districtid?: number;
    districtname?: string;
    districtnamenepali?: string;
    district_active?: boolean;
    paliaka?: PalikaVm;
}

export interface PalikaVm {
    palikaid?: number;
    palikaname?: string;
    palikanamenepali?: string;
    palikaactive?: boolean;
}

export interface ApproveProvinceDistrictPalika {
    provinceid?: number;
    province_is_active?: boolean;
    districtid?: number;
    district_is_active?: boolean;
    palikaid?: number;
    palika_is_active?: boolean;
}

export interface ResponseOfUserWithNavigation {
    message?: string;
    status?: string;
    data?: UserWithNavigation;
}

export interface UserWithNavigation {
    userID?: string;
    userName?: string;
    role?: string;
    email?: string;
    displayname?: string;
    navigations?: Navigation[];
}

export interface Navigation {
    navigation_id?: number;
    title?: string;
    link?: string;
    type?: string;
    parent_navigation_id?: number;
    root_navigation_id?: number;
    icon?: string;
    display_order?: number;
    showin_ui?: boolean;
    can_create?: boolean;
    can_review?: boolean;
    can_approve?: boolean;
    can_allow?: boolean;
    can_delete?: boolean;
    can_full_access?: boolean;
    children?: Navigation[];
}

export interface GiveAcessForFiscalYear {
    fiscalid?: number;
    fy_locked?: boolean;
    fiscalYearDetail?: GiveAcessForFiscalYearDetail[];
}

export interface GiveAcessForFiscalYearDetail {
    fy_detail_id?: number;
    fy_detail_locked?: boolean;
}

export interface ResponseOfListOfFiscalYearsDto {
    message?: string;
    status?: string;
    data?: FiscalYearsDto[];
}

export interface FiscalYearsDto {
    fiscalid?: number;
    name?: string;
    fy_locked?: boolean;
}

export interface ResponseOfListOfFiscalDetailDto {
    message?: string;
    status?: string;
    data?: FiscalDetailDto[];
}

export interface FiscalDetailDto {
    fiscal_detail_id?: number;
    fiscal_id?: number;
    fydetail_name?: string;
    fydetail_nepali_name?: string;
    from?: Date;
    to?: Date;
    fy_type?: string;
    locked?: boolean;
}

export interface ResponseOfApplicationUser {
    message?: string;
    status?: string;
    data?: ApplicationUser;
}

export interface IdentityUserOfString {
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
}

export interface IdentityUser extends IdentityUserOfString {
}

export interface ApplicationUser extends IdentityUser {
    fullName?: string;
    isactive?: boolean;
}

export interface ResponseOfLoginReturnTypeDto {
    message?: string;
    status?: string;
    data?: LoginReturnTypeDto;
}

export interface LoginReturnTypeDto {
    userid?: string;
    role?: string;
    roleId?: string;
    jwt?: string;
    displayName?: string;
    navigation?: any;
    email?: string;
}

export interface ResponseOfUserPassword {
    message?: string;
    status?: string;
    data?: UserPassword;
}

export interface UserPassword {
    oldPassword?: string;
    newPassword?: string;
    confirmNewPassword?: string;
}

export interface ResponseOfChangePassword {
    message?: string;
    status?: string;
    data?: ChangePassword;
}

export interface UserPasswordDto {
    oldPassword?: string;
    newPassword?: string;
    confirmNewPassword?: string;
}

export interface ChangePasswordDto extends UserPasswordDto {
    userName?: string;
}

export interface ChangePassword extends ChangePasswordDto {
}

export interface ResponseOfListOfUserListDto {
    message?: string;
    status?: string;
    data?: UserListDto[];
}

export interface UserListDto {
    user_name?: string;
    id?: string;
    full_name?: string;
    role?: string;
    email?: string;
    phone_number?: string;
    is_active?: boolean;
    totalCount?: number;
}

export interface ResponseOfListOfSelectListModel {
    message?: string;
    status?: string;
    data?: SelectListModel[];
}

export interface SelectListModel {
    key?: string;
    value?: string;
    points?: number;
    isChecked?: boolean;
}

export interface ResponseOfListOfApplicationUser {
    message?: string;
    status?: string;
    data?: ApplicationUser[];
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}